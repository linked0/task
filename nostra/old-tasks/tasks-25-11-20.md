Written on 2025-11-20 09:22:01 +09:00

# Summary
This is the list of additional tasks in response to your latest implementation of the detail page. Your workspace should be in the `/Users/jay/work/nostra-server` and `/Users/jay/work/nostra-contracts` folders.

# For Github Commit 
You can commit the changes with a proper commit message. But don't add the following lines showing that the code is generated by Claude or any other AI.
```
ğŸ¤– Generated with [Claude Code](https://claude.com/claude-code)

Co-Authored-By: Claude <noreply@anthropic.com>
```

# Prerequisites
Before checking the Tasks, you should review the "Basic" sections to avoid confusing the UI representation with the underlying process. Keep this in mind when implementing the detail page.

# Basic 1
The best ask price in the orderbook should be on the bottom. 

# Basic 2
The spread is 2% of the fair market price (50Â¢) which is 1% on each side. 

# Basic 3 
After trade execution, the shares and total values in the orderbook should be updated to reflect the executed trade. When a user buys shares, the corresponding shares and total values in the orderbook should decrease; when a user sells, they should increase. You should save executed trades to the database and update the orderbook based on these trades to ensure accuracy and consistency. Ensure that trades don't fail with the error: "Failed to save trade or update price: totalShares.toFixed is not a function".

# Task-1
This is what we discussed in the past. Do it as we discussed.

You know we currently have two market types: market groups (containing multiple binary markets) and single binary markets. However, users unfamiliar with future-market-style UIs (multiple Yes/Nos) might find this uncomfortable. Therefore, I think it would be great to add a new kind of market that is multiple-choice but not a market group. 

Do you understand? Is it difficult, complex, or does it require too many changes to add this feature? I'm just askingâ€”don't change the code yet. Before we start, is this the right direction? :) 

âº Great question! Let me analyze whether this is a good direction and how complex it
  would be.

  Understanding Your Proposal

  Current Market Types:
  1. Market Group (Grouped Binary) - Multiple binary markets
    - Example: "World Series MVP" â†’ 5 players, each with YES/NO
    - UI: 5 cards, each showing "Buy Yes 55Â¢ / Buy No 45Â¢"
  2. Single Binary Market - One simple YES/NO
    - Example: "Will tariffs be upheld?"
    - UI: One card with "Buy Yes 60Â¢ / Buy No 40Â¢"

  Your Proposed Addition:
  3. Multi-Choice Market (NOT grouped) - One market, multiple choices
  - Example: "Who will win World Series MVP?"
  - Choices: Ohtani (55%), Judge (25%), Freeman (15%), Betts (5%)
  - UI: Pick ONE winner, not YES/NO for each

  Is This the Right Direction?

  âœ… YES! This is a GREAT idea! Here's why:

  1. Better UX for Casual Users

  Current (Market Group):
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ âš¾ Shohei Ohtani           â”‚
  â”‚ Buy Yes 55Â¢ | Buy No 45Â¢   â”‚  â† Confusing for new users
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ âš¾ Aaron Judge              â”‚
  â”‚ Buy Yes 25Â¢ | Buy No 75Â¢   â”‚  â† "Why would I buy No?"
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

  Proposed (Multi-Choice):
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ Who will win World Series MVP?         â”‚
  â”‚                                         â”‚
  â”‚ â—‹ Shohei Ohtani    55Â¢    (55%)       â”‚ â† Clear winner pick
  â”‚ â—‹ Aaron Judge      25Â¢    (25%)       â”‚ â† Intuitive
  â”‚ â—‹ Freddie Freeman  15Â¢    (15%)       â”‚
  â”‚ â—‹ Mookie Betts     5Â¢     (5%)        â”‚
  â”‚                                         â”‚
  â”‚ [Buy Selected Choice]                   â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

  2. Familiar Mental Model

  - Like voting in an election ğŸ—³ï¸
  - Like answering a multiple-choice quiz ğŸ“
  - Like betting on horse racing ğŸ‡
  - Users think: "Who will win?" not "Will X win?"

  3. Clearer Probability Display

  Market Group (confusing):
  - Ohtani YES: 55%  NO: 45%
  - Judge YES: 25%   NO: 75%
  - Freeman YES: 15% NO: 85%
  â“ Why don't these add to 100%?

  Multi-Choice (clear):
  - Ohtani: 55%
  - Judge: 25%
  - Freeman: 15%
  - Betts: 5%
  âœ… Total: 100% (makes sense!)

  Technical Complexity Assessment

  ğŸŸ¢ LOW COMPLEXITY - Already Supported!

  The amazing news: ConditionalTokens ALREADY supports this!

  Smart Contract Layer (No Changes Needed!)

  // Current binary market
  await conditionalTokens.prepareCondition(
    oracle,
    questionId,
    2  // â† 2 outcomes (YES, NO)
  );

  // New multi-choice market
  await conditionalTokens.prepareCondition(
    oracle,
    questionId,
    5  // â† 5 outcomes (Ohtani, Judge, Freeman, Betts, Other)
  );

  ConditionalTokens supports ANY number of outcomes! 2, 3, 4, 5, 10, etc.

  Splitting Still Works

  // Split 200 USDC into 5 outcome tokens
  await conditionalTokens.splitPosition(
    mockUSDCAddress,
    ethers.zeroPadValue('0x00', 32),
    conditionId,
    [1, 2, 4, 8, 16],  // â† 5 outcomes (binary positions)
    ethers.parseUnits('200', 6)
  );

  // Result:
  // Operator gets:
  // - 200 Ohtani tokens
  // - 200 Judge tokens
  // - 200 Freeman tokens
  // - 200 Betts tokens
  // - 200 Other tokens

  Database (Minimal Changes)

  model Market {
    id           String       @id
    conditionId  String       @unique
    title        String
    description  String
    category     String
    marketType   MarketType   @default(BINARY)  // â† Add this enum

    outcomes     Outcome[]
  }

  enum MarketType {
    BINARY              // Single YES/NO
    MULTI_CHOICE        // Multiple options (NEW!)
    GROUPED_BINARY      // Market group
  }

  model Outcome {
    id           String  @id
    marketId     String
    conditionId  String
    tokenId      String
    title        String         // "Shohei Ohtani" (not "Yes"/"No")
    position     Int            // 0, 1, 2, 3, 4 (not just 0/1)
    currentPrice Decimal
    probability  Decimal
  }

  ğŸŸ¡ MEDIUM COMPLEXITY - UI Changes

  1. New Market Card Component

  // Location: web/src/components/MultiChoiceCard.tsx (NEW)

  export function MultiChoiceCard({ market }) {
    const [selectedChoice, setSelectedChoice] = useState(null);

    return (
      <Card>
        <CardHeader>
          <h3>{market.title}</h3>
          <p>Pick the winner</p>
        </CardHeader>

        <CardContent>
          {market.outcomes.map((outcome) => (
            <div 
              key={outcome.id}
              className={selectedChoice === outcome.id ? 'selected' : ''}
              onClick={() => setSelectedChoice(outcome.id)}
            >
              <Radio checked={selectedChoice === outcome.id} />
              <span>{outcome.title}</span>
              <span>{(outcome.currentPrice * 100).toFixed(0)}Â¢</span>
              <span>({outcome.probability.toFixed(0)}%)</span>
            </div>
          ))}

          <Button 
            onClick={() => handleBuy(selectedChoice)}
            disabled={!selectedChoice}
          >
            Buy Selected Choice
          </Button>
        </CardContent>
      </Card>
    );
  }

  2. Market List Page Update

  // Location: web/src/app/page.tsx

  {markets.map((market) => {
    switch (market.marketType) {
      case 'BINARY':
        return <BinaryMarketCard market={market} />;

      case 'MULTI_CHOICE':
        return <MultiChoiceCard market={market} />;  // â† NEW

      case 'GROUPED_BINARY':
        return <MarketGroupCard marketGroup={market} />;
    }
  })}

  3. Detail Page Update

  Similar changes for the market detail page to show multi-choice orderbook.

  ğŸ“Š Effort Estimation

  | Component              | Complexity | Effort                           |
  |------------------------|------------|----------------------------------|
  | Smart Contracts        | âœ… None     | 0 hours (already supported!)     |
  | Database Schema        | ğŸŸ¢ Low     | 1 hour (add enum, migration)     |
  | Market Creation Script | ğŸŸ¢ Low     | 2 hours (support N outcomes)     |
  | Frontend Components    | ğŸŸ¡ Medium  | 8 hours (new UI components)      |
  | API Updates            | ğŸŸ¢ Low     | 2 hours (handle marketType)      |
  | Testing                | ğŸŸ¡ Medium  | 4 hours (test multi-choice flow) |
  | Total                  |            | ~17 hours (2-3 days)             |

  Comparison with Market Group

  Market Group (Current)

  "World Series MVP"
  â”œâ”€ Market 1: "Will Ohtani win?" (YES/NO)
  â”œâ”€ Market 2: "Will Judge win?" (YES/NO)
  â”œâ”€ Market 3: "Will Freeman win?" (YES/NO)
  â”œâ”€ Market 4: "Will Betts win?" (YES/NO)
  â””â”€ Market 5: "Will Other win?" (YES/NO)

  Database:
  - 1 MarketGroup
  - 5 Markets (each with conditionId)
  - 10 Outcomes total (5 Ã— 2)

  Blockchain:
  - 5 separate conditions
  - 10 token types

  Multi-Choice (Proposed)

  "Who will win World Series MVP?"
  â”œâ”€ Choice 1: Ohtani (40 tokens)
  â”œâ”€ Choice 2: Judge (40 tokens)
  â”œâ”€ Choice 3: Freeman (40 tokens)
  â”œâ”€ Choice 4: Betts (40 tokens)
  â””â”€ Choice 5: Other (40 tokens)

  Database:
  - 1 Market (marketType: MULTI_CHOICE)
  - 5 Outcomes (positions 0-4)

  Blockchain:
  - 1 condition
  - 5 token types

  Multi-choice is actually SIMPLER on the blockchain!

  Recommendation

  âœ… YES, this is the RIGHT direction!

  Why:
  1. Better UX - Familiar, intuitive for casual users
  2. Already supported - ConditionalTokens handles it natively
  3. Reasonable effort - ~2-3 days of development
  4. Cleaner architecture - One condition vs. multiple conditions
  5. More flexible - Can have 3, 5, 10, or any number of choices

  When to use each type:

  | Market Type    | Use Case                    | Example
            |
  |----------------|-----------------------------|--------------------------------------
  ----------|
  | Binary         | Simple yes/no question      | "Will Bitcoin hit $100k in 2024?"
            |
  | Multi-Choice   | Pick one winner from many   | "Who will win Super Bowl MVP?"
            |
  | Grouped Binary | Multiple independent events | "Which teams make playoffs?" (can be
  multiple) |

  Key Difference:
  - Multi-Choice: EXACTLY ONE outcome wins (mutually exclusive)
  - Grouped Binary: MULTIPLE outcomes can win (independent events)

  Implementation Strategy

  Phase 1: Backend (1 day)

  1. Add marketType enum to database
  2. Update market creation script to support N outcomes
  3. Update API to handle multi-choice markets

  Phase 2: Frontend (1 day)

  1. Create MultiChoiceCard component
  2. Update market list page
  3. Update detail page for multi-choice orderbook

  Phase 3: Testing (0.5 days)

  1. Create test multi-choice market
  2. Test trading flow
  3. Test redemption after resolution

You implementation should have change in related scripts like market creation script.


# Task-2
Based on Task-1, we should update the market creation page to support the new market type. We need to add a new field called `marketType` to the market creation page. The default value should be `BINARY`, and the other options should be `MULTI_CHOICE` and `GROUPED_BINARY`. Follow all rules and policies from the Task-1 implementation.

# Task-3
We need to implement the resolve function for a market group or single market. The resolve button is located on the market detail page. When the user clicks the resolve button, the backend should call the resolve function. The important thing is to distribute mUSDC to the winners, deducting a 4% fee from the total mUSDC for the platform and market creator. 

# Task-4
Currently, the number of asks/bids in the orderbook section is 2 each. We should change it to 5.

# Task-5
Hybrid Market Maker Bot - Requirements Summary

  Overview

  Purpose: Create a bot that combines market making (provides liquidity) and arbitrage
  (exploits mispricing) strategies to manage prediction market liquidity automatically.

  Current Problem:
  - Existing MarketMakerBot only does arbitrage (TAKER role)
  - Doesn't post orders to orderbook
  - Doesn't provide continuous liquidity
  - Doesn't earn spread revenue

  Solution: Hybrid bot with dual strategies

  ---
  Core Strategies

  Strategy 1: Market Making (Primary, Continuous)

  Goal: Provide liquidity by posting buy/sell orders with a spread

  Behavior:
  - For each active outcome in ACTIVE_ORDERS markets:
    - Calculate fair price from currentPrice
    - Post BUY limit order at fairPrice - spread (e.g., $0.48)
    - Post SELL limit order at fairPrice + spread (e.g., $0.52)
    - Store signed orders in database (Order table)
    - Track posted orders for later cancellation

  Order Management:
  - Monitor price changes every 30 seconds
  - Cancel stale orders when prices move
  - Repost orders at updated prices
  - Cancel all orders when switching to arbitrage mode

  Revenue: Earn spread (2-4Â¢) when both sides fill

  Strategy 2: Arbitrage (Opportunistic, High Priority)

  Goal: Exploit multi-choice market inefficiencies

  Detection:
  - Calculate sum of YES prices across grouped markets
  - If sum > botUpperThreshold (e.g., 105%): SELL opportunity
  - If sum < botLowerThreshold (e.g., 95%): BUY opportunity
  - Only execute if profit > minProfitPerSet (e.g., $0.02)

  Execution:
  1. Cancel all posted market making orders
  2. Execute market orders (TAKER) to capture arbitrage
  3. Wait cooldown period (e.g., 60 seconds)
  4. Resume market making with fresh orders

  Revenue: Profit from mispricing (5Â¢+ per set)

  ---
  Auto-Discovery System

  Database-Driven Configuration

  No code changes needed for new markets!

  Bot queries database every 30 seconds:
  SELECT * FROM market_groups
  WHERE status = 'ACTIVE'
    AND liquidity_mode = 'ACTIVE_ORDERS'

  Market Group Configuration (Existing Schema)

  Use existing columns in market_groups table:
  - liquidityMode: 'NONE' | 'ON_DEMAND' | 'ACTIVE_ORDERS'
  - botUpperThreshold: Arbitrage sell threshold (e.g., 1.05 = 105%)
  - botLowerThreshold: Arbitrage buy threshold (e.g., 0.95 = 95%)
  - botMaxPosition: Max USDC per market (e.g., 200)

  How It Works

  Market Creation:
  // Admin creates market with bot config
  await prisma.marketGroup.create({
    data: {
      name: "2026 World Cup Winner",
      liquidityMode: 'ACTIVE_ORDERS',  // â† Bot will handle
      botUpperThreshold: 1.05,
      botLowerThreshold: 0.95,
      botMaxPosition: 200,
      markets: [ /* ... */ ]
    }
  });
  // Bot discovers automatically in next 30s cycle!

  Market Resolution:
  // Admin resolves market
  await prisma.marketGroup.update({
    where: { id: 'market-id' },
    data: { status: 'RESOLVED' }
  });
  // Bot stops handling automatically in next cycle!

  ---
  Priority & Resource Management

  Priority System

  Calculate priority score for each market group:
  - Higher trading volume = higher priority
  - Closer to expiry = higher priority
  - Premium tier (high botMaxPosition) = bonus priority
  - Sort by priority, handle top N groups first

  Resource Limits

  Capital Management:
  - Track total capital allocated across all markets
  - Max total capital: $10,000 (configurable)
  - Per-market capital: botMaxPosition * numberOfMarkets
  - Skip low-priority markets if capital exhausted

  Concurrency Limits:
  - Max concurrent market groups: 50 (configurable)
  - Process high-priority groups first
  - Queue or skip low-priority groups

  Risk Controls:
  - Max position per outcome
  - Max total exposure across all positions
  - Emergency stop mechanism
  - Dry-run mode for testing

  ---
  Technical Requirements

  1. Order Signing (EIP-712)

  Functionality:
  - Sign orders with bot's private key
  - Generate orderHash (keccak256 of order struct)
  - Support both BUY and SELL orders
  - Include all required fields (maker, taker, amounts, expiration, etc.)

  Order Structure:
  interface SignedOrder {
    salt: string;
    maker: string;           // Bot wallet address
    signer: string;          // Bot wallet address
    taker: string;           // 0x0000... (anyone can take)
    tokenId: string;
    side: 'BUY' | 'SELL';
    makerAmount: string;     // Raw units (6 decimals)
    takerAmount: string;
    price: string;
    expiration: Date;
    nonce: bigint;
    feeRateBps: number;
    signature: string;       // EIP-712 signature
    signatureType: string;   // 'EOA'
    orderHash: string;       // keccak256 hash
  }

  2. Order Posting to Database

  Insert orders into Order table:
  await prisma.order.create({
    data: {
      orderHash,
      salt,
      maker,
      signer,
      taker,
      marketId,
      outcomeId,
      tokenId,
      side: 'BUY',
      makerAmount,
      takerAmount,
      price,
      originalSize,
      remainingSize,
      feeRateBps,
      expiration,
      signature,
      signatureType: 'EOA',
      status: 'OPEN',
      isActive: true
    }
  });

  Track posted orders:
  - Store mapping: outcomeId â†’ orderHash[]
  - Enable cancellation of specific orders
  - Track BUY vs SELL orders separately

  3. Order Cancellation

  Cancel orders:
  - Update database: status = 'CANCELLED', isActive = false
  - OR delete from database entirely
  - Track cancellation timestamp

  When to cancel:
  - Price changed significantly (need to reprice)
  - Switching to arbitrage mode
  - Market resolved
  - Bot shutdown

  4. Price Monitoring

  Track fair price changes:
  - Monitor currentPrice in Outcome table
  - Detect when price moves > threshold (e.g., 2%)
  - Trigger order repricing

  Spread calculation:
  - Fixed spread: 2-4Â¢ (configurable per tier)
  - Or percentage-based: 2-5% of fair price
  - Wider spread for volatile markets

  5. Inventory Management

  Position Tracking:
  - Track shares held per outcome
  - Calculate current value of positions
  - Monitor profit/loss (realized + unrealized)

  Position Limits:
  - Max shares per outcome (prevent concentration)
  - Max total position value (risk management)
  - Alert on high exposure

  6. Logging & Monitoring

  Comprehensive logging:
  - Market discovery events
  - Order posting/cancellation
  - Arbitrage opportunities detected
  - Trade executions (success/failure)
  - Position updates
  - Profit tracking
  - Error handling

  Statistics tracking:
  - Total trades executed
  - Total profit earned (spread + arbitrage)
  - Current positions across all markets
  - Capital utilization
  - Success rate

  ---
  Bot Execution Flow

  Startup

  1. Initialize bot with configuration
  2. Connect to database (Prisma)
  3. Connect to blockchain (ethers.js)
  4. Load bot wallet from private key
  5. Initialize MarketOrderService
  6. Start polling loop (30s interval)

  Each Polling Cycle (Every 30 seconds)

  1. Market Discovery:
  Query database for active groups with ACTIVE_ORDERS mode
    â†“
  Calculate priority scores
    â†“
  Sort by priority
    â†“
  Select top N groups (within resource limits)

  2. For Each Market Group:
  Load group configuration (thresholds, max position)
    â†“
  Load all markets and outcomes
    â†“
  Check arbitrage opportunity FIRST (higher priority)
    â†“
  If arbitrage found:
    - Cancel all market making orders
    - Execute arbitrage trades (market orders)
    - Wait cooldown period
    - Resume market making
    â†“
  Else (no arbitrage):
    - Check if posted orders need repricing
    - If yes: Cancel old orders, post new orders
    - If no: Continue monitoring

  3. Cleanup:
  Cancel orders for resolved markets
    â†“
  Release capital from resolved markets
    â†“
  Update statistics
    â†“
  Log cycle summary

  Shutdown

  1. Cancel all active orders
  2. Log final statistics
  3. Close database connections
  4. Exit gracefully

  ---
  Configuration Examples

  Premium Tier (High-Value Market)

  {
    liquidityMode: 'ACTIVE_ORDERS',
    botUpperThreshold: 1.03,      // Tight (3%)
    botLowerThreshold: 0.97,
    botMaxPosition: 500,          // $500 per market
    spread: 0.02                  // 2Â¢ spread
  }

  Standard Tier (Regular Market)

  {
    liquidityMode: 'ACTIVE_ORDERS',
    botUpperThreshold: 1.05,      // Normal (5%)
    botLowerThreshold: 0.95,
    botMaxPosition: 100,          // $100 per market
    spread: 0.04                  // 4Â¢ spread
  }

  Community Tier (Low Volume)

  {
    liquidityMode: 'ON_DEMAND',   // No bot posting
    botUpperThreshold: null,
    botLowerThreshold: null,
    botMaxPosition: null
  }

  No Bot (Pure Community)

  {
    liquidityMode: 'NONE',
    // Bot completely ignores
  }

  ---
  Implementation Checklist

  Core Functionality

  - Order signing with EIP-712
  - Order posting to database
  - Order cancellation logic
  - Market discovery query
  - Priority calculation
  - Resource management (capital limits)
  - Inventory tracking

  Market Making Strategy

  - Fair price calculation
  - Spread calculation (fixed or percentage)
  - BUY order generation
  - SELL order generation
  - Price monitoring
  - Order repricing logic

  Arbitrage Strategy

  - Multi-choice sum calculation
  - Threshold detection (upper/lower)
  - Profit calculation
  - Market order execution
  - Cooldown period
  - Resume market making

  Safety & Monitoring

  - Dry-run mode
  - Position limits
  - Capital limits
  - Emergency stop
  - Comprehensive logging
  - Statistics tracking
  - Error handling

  Testing

  - Unit tests for order signing
  - Integration tests on testnet
  - Dry-run testing in production
  - Monitoring and alerts

  ---
  Expected Outcomes

  Benefits:
  1. âœ… Automatic liquidity provisioning
  2. âœ… Two revenue streams (spread + arbitrage)
  3. âœ… Zero-config for new markets
  4. âœ… Auto-cleanup for resolved markets
  5. âœ… Scalable to 50+ market groups
  6. âœ… Resource-aware allocation
  7. âœ… Professional market operation

  Estimated Effort: 3-5 days for full implementation

  Success Metrics:
  - Orders posted within 30s of market creation
  - Arbitrage opportunities captured within 30s
  - 95%+ uptime
  - Profitable spread + arbitrage revenue
  - No manual intervention needed

Good Luck! :)